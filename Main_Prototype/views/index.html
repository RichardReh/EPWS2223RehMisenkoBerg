<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/styles.css">
    <title>EP2023</title>
</head>
<body>
    <div class="headline">
        <h1>EP2023</h1>
    </div>
    <div class="field_container">
        <div class="create_button">
            <button id = "btnCreate">Sitzung erstellen</button>
        </div>
        <div class="join_options">
            <input type = "text" placeholder="Nutzername" id = "txtNameId">
            <input type = "text" placeholder="SessionId" id = "txtSessionId">
            <button id = "btnJoin">Sitzung beitretten</button>
        </div>
        <div class="join_code" id="join_code">

        </div>
    </div>
    <div id="div_users">

    </div>
    <div class="image_html_section">
        <div>
            <!--Lösch-Funktion für alle erstellte Zeichnungen-->
            <button onclick="javascript:clearArea();return false;">Clear</button>

            <button onclick="javascript:undo();return false;">Undo</button>

            <!--Linien Größen für das Zeichnen-->
            Line width : <select id="selWidth">
                <option value="10">10</option>
                <option value="20" selected="selected">20</option>
                <option value="30">30</option>
            </select>

            <!--Farbauswahl für das Zeichnen-->
            Color : <select id="selColor">
                <option value="black">black</option>
                <option value="blue" selected="selected">blue</option>
                <option value="red">red</option>
                <option value="green">green</option>
                <option value="yellow">yellow</option>
                <option value="gray">gray</option>
                <option value="white">white</option>
            </select>

        </div>
        <input type="file" id="image_input" accept="image/png, image/jpg">

        <canvas id="imageCanvas"></canvas>
        <!--<img src="" id="display_image"></img>-->
    </div>
</body>
<script>
    let clientId = null;
    var sessionId = ""
    // Aus irgend einem Grund wird die sessionId als undefined im untersten Codeblock für die Image
    // sende-logik gespeichert und lässt sich nicht ein mal korrekt referenzieren.
    // darum benutzen wir die "sessionId_for_image_send"
    var sessionId_for_image_send = ""
    var clientId_for_undo_or_clear = ""

    let ws = new WebSocket("ws://localhost:8003")

    const btnJoin = document.getElementById("btnJoin");
    const txtSessionId = document.getElementById("txtSessionId");
    const btnCreate = document.getElementById("btnCreate");
    const nutzername = document.getElementById("txtNameId");
    const div_users = document.getElementById("div_users")
    const joincode = document.getElementById("join_code");

    //Button für die Erstellung einer Sitzung
    btnCreate.addEventListener("click", e =>{

        const payLoad = {
            "method": "create",
            "clientId": clientId
        }

        ws.send(JSON.stringify(payLoad));
    })


    btnJoin.addEventListener("click", e =>{

    
    sessionId = txtSessionId.value

    sessionId_for_image_send = sessionId


    const payLoad = {
        "method": "join",
        "clientId": clientId,
        "sessionId": sessionId,
        "nutzername" : nutzername.value
    }
    ws.send(JSON.stringify(payLoad));


    })


    ws.onmessage = message => {
        const response = JSON.parse(message.data);
        
        if(response.method === "connect"){
            clientId = response.clientId;
            //Client Id ausgeben
            console.log(clientId)

            clientId_for_undo_or_clear = clientId
        }

        if (response.method === "create"){
            sessionId = response.session.id

            console.log("Das ist meine SessionId",sessionId)

            let d = document.createElement("h2")
            d.textContent = "SessionID:  " + sessionId
            d.style.fontFamily = "Arial"

            joincode.appendChild(d)

        }

        if (response.method === "join"){
            sessionId = response.session.sessionId
            let session = response.session

        
            console.log(div_users)
                //console.log(element.nutzername)

            while(div_users.firstChild){
                div_users.removeChild(div_users.firstChild)
            } 

            session.clients.forEach(c => {
                const d = document.createElement("div")
                d.textContent = c.nutzername
                d.style.fontFamily = "Impact, Haettenschweiler"
                d.style.fontSize = "xx-large"
                div_users.appendChild(d)
            });

            if(session.image != ""){
                const encodedImage = new Image()
                encodedImage.onload = function() {
                    var canvas = document.getElementById('imageCanvas');
                    canvas.width = encodedImage.width;
                    canvas.height = encodedImage.height;
                    var ctx = canvas.getContext('2d');
                    ctx.drawImage(encodedImage,0,0);
                }
                encodedImage.src = session.image
            }
        }

        if (response.method === "get_image"){
            const image = response.image
            const newImage = response.newImage

            //console.log("DAS IST DAS BILD:  "+ image)

            const encodedImage = new Image()
            encodedImage.onload = function() {
                var canvas = document.getElementById('imageCanvas');
                canvas.width = encodedImage.width;
                canvas.height = encodedImage.height;
                var ctx = canvas.getContext('2d');
                ctx.drawImage(encodedImage,0,0);

                const imageData = context.getImageData(0, 0, canvas.width, canvas.height)
                restore_array.push(imageData)
                index += 1

                if(newImage){
                    initialImage = context.getImageData(0, 0, canvas.width, canvas.height)
                    restore_array = [];
                    index = -1;
                }
            }
            encodedImage.src = image

            //console.log("DAS IST DAS ENKODIERTE BILD:  "+ encodedImage.src)

        }

        if (response.method === "undoImage"){
            if(index <= 0){
            restore_array = [];
            index = -1;

            //var jpegUrl = ""
            //const encodedImage = new Image()
            //encodedImage.onload = function() {
            //    var canvas = document.getElementById('imageCanvas');
            //    canvas.width = encodedImage.width;
            //    canvas.height = encodedImage.height;
            //    var ctx = canvas.getContext('2d');
            //    ctx.drawImage(encodedImage,0,0);
            //    jpegUrl = canvas.toDataURL("image/jpeg");
            //}
            //encodedImage.src = initialImage
            context.putImageData(initialImage, 0 , 0)

            } else {
                restore_array.pop();
                index -= 1
                context.putImageData(restore_array[index], 0, 0)
                //var jpegUrl = canvas.toDataURL("image/jpeg");
            }
        }

        if (response.method === "clearImage"){
            if(initialImage != ""){
            //    var jpegUrl = ""
            //    const encodedImage = new Image()
            //    encodedImage.onload = function() {
            //        var canvas = document.getElementById('imageCanvas');
            //        canvas.width = encodedImage.width;
            //        canvas.height = encodedImage.height;
            //        var ctx = canvas.getContext('2d');
            //        ctx.drawImage(encodedImage,0,0);
            //        jpegUrl = canvas.toDataURL("image/jpeg");
                    //console.log(jpegUrl)
            //    }
            //    encodedImage.src = initialImage
            context.putImageData(initialImage, 0 , 0)

                restore_array = [];
                index = -1;
            }
        }

        if (response.method === "error"){
            console.log(response.message) 
        }

    } 

    // LOGIK FÜR DEN IMAGE UPLOAD

    const image_input = document.querySelector("#image_input");
    //var uploaded_image = "";

    //image_input.addEventListener("change", function(){
    //    const reader = new FileReader();
    //    reader.addEventListener("load", () => {
    //        uploaded_image = reader.result;
    //        document.querySelector("#display_image").src = uploaded_image

        var imageLoader = document.getElementById('image_input');
        imageLoader.addEventListener('change', handleImage, false);
        var canvas = document.getElementById('imageCanvas');
        var context = canvas.getContext('2d');

        var initialImage = ""
        let restore_array = [];
        let index = -1;

        function handleImage(e){
            var reader = new FileReader();
            reader.onload = function(event){
                var img = new Image();
                img.onload = function(){

                    canvas.width = img.width;
                    canvas.height = img.height;
                    context.drawImage(img,0,0);
                    initialImage = context.getImageData(0, 0, canvas.width, canvas.height)
                    restore_array = [];
                    index = -1;
                }
            img.src = event.target.result;
            var sendableImage = event.target.result;

                if(sessionId_for_image_send != ""){
                const payLoad = {
                    "method": "upload_image",
                    "clientId": clientId_for_undo_or_clear,
                    "sessionId": sessionId_for_image_send,
                    "image" : sendableImage,
                    "newImage" : true
                }
                ws.send(JSON.stringify(payLoad));
                }
            }
            reader.readAsDataURL(e.target.files[0]);     
        }
                

    //        if(sessionId_for_image_send != ""){
    //            const payLoad = {
    //            "method": "upload_image",
    //            "clientId": clientId,
    //            "sessionId": sessionId_for_image_send,
    //            "image" : uploaded_image,
    //        }

    //        ws.send(JSON.stringify(payLoad));
    //        }

    //    });
    //    reader.readAsDataURL(this.files[0]);
    //});

    //Canvas Funktionen

    let isDrawing = false;
    let x = 0;
    let y = 0;
    var offsetX;
    var offsetY;

    function startup() {
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleCancel);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('mousedown', (e) => {
            x = e.offsetX;
            y = e.offsetY;
            isDrawing = true;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
            drawLine(context, x, y, e.offsetX, e.offsetY);
            x = e.offsetX;
            y = e.offsetY;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDrawing) {
            drawLine(context, x, y, e.offsetX, e.offsetY);
            x = 0;
            y = 0;
            isDrawing = false;
            }

            if(e.type != 'mouseout'){
                restore_array.push(context.getImageData(0, 0, canvas.width, canvas.height));
                index += 1;
            }

            var jpegUrl = canvas.toDataURL("image/jpeg");

            const payLoad = {
                "method" : "upload_image",
                "clientId" : clientId_for_undo_or_clear,
                "sessionId" : sessionId_for_image_send,
                "image" : jpegUrl,
                "newImage" : false
            }

            ws.send(JSON.stringify(payLoad));

            console.log(restore_array)
        });
    }

    document.addEventListener("DOMContentLoaded", startup);

    const ongoingTouches = [];

    function handleStart(evt) {
        evt.preventDefault();
        const touches = evt.changedTouches;
        offsetX = canvas.getBoundingClientRect().left;
        offsetY = canvas.getBoundingClientRect().top;
        for (let i = 0; i < touches.length; i++) {
            ongoingTouches.push(copyTouch(touches[i]));
        }
    }

    function handleMove(evt) {
        evt.preventDefault();
        const touches = evt.changedTouches;
        for (let i = 0; i < touches.length; i++) {
            const color = document.getElementById('selColor').value;
            const idx = ongoingTouchIndexById(touches[i].identifier);
            if (idx >= 0) {
            context.beginPath();
            context.moveTo(ongoingTouches[idx].clientX - offsetX, ongoingTouches[idx].clientY - offsetY);
            context.lineTo(touches[i].clientX - offsetX, touches[i].clientY - offsetY);
            context.lineWidth = document.getElementById('selWidth').value;
            context.strokeStyle = color;
            context.lineJoin = "round";
            context.closePath();
            context.stroke();
            ongoingTouches.splice(idx, 1, copyTouch(touches[i]));
            }
        }
    }

    function handleEnd(evt) {
        evt.preventDefault();
        const touches = evt.changedTouches;
        for (let i = 0; i < touches.length; i++) {
            const color = document.getElementById('selColor').value;
            let idx = ongoingTouchIndexById(touches[i].identifier);
            if (idx >= 0) {
            context.lineWidth = document.getElementById('selWidth').value;
            context.fillStyle = color;
            ongoingTouches.splice(idx, 1);  
            }
        }
    }

    function handleCancel(evt) {
        evt.preventDefault();
        const touches = evt.changedTouches;
        for (let i = 0; i < touches.length; i++) {
            let idx = ongoingTouchIndexById(touches[i].identifier);
            ongoingTouches.splice(idx, 1);  
        }
    }

    function copyTouch({ identifier, clientX, clientY }) {
        return { identifier, clientX, clientY };
    }

    function ongoingTouchIndexById(idToFind) {
        for (let i = 0; i < ongoingTouches.length; i++) {
            const id = ongoingTouches[i].identifier;
            if (id === idToFind) {
            return i;
            }
        }
        return -1;  
    }

    function drawLine(context, x1, y1, x2, y2) {
        context.beginPath();
        context.strokeStyle = document.getElementById('selColor').value;
        context.lineWidth = document.getElementById('selWidth').value;
        context.lineJoin = "round";
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.closePath();
        context.stroke();
    }

    function clearArea() {

        if(initialImage != ""){

            //var jpegUrl = ""
            //const encodedImage = new Image()
            //encodedImage.onload = function() {
            //    var canvas = document.getElementById('imageCanvas');
            //    canvas.width = encodedImage.width;
            //    canvas.height = encodedImage.height;
            //    var ctx = canvas.getContext('2d');
            //    ctx.drawImage(encodedImage,0,0);
            //    jpegUrl = canvas.toDataURL("image/jpeg");
            //    //console.log(jpegUrl)
            //}
            //encodedImage.src = initialImage

            context.putImageData(initialImage, 0, 0)

            restore_array = [];
            index = -1;

            const payLoad = {
                "method" : "clear",
                "clientId" : clientId_for_undo_or_clear,
                "sessionId" : sessionId_for_image_send,
            }

            ws.send(JSON.stringify(payLoad));
        }
    }

    function undo() {
        if(index <= 0){

            restore_array = [];
            index = -1;
            
            //var jpegUrl = ""
            //const encodedImage = new Image()
            //encodedImage.onload = function() {
            //    var canvas = document.getElementById('imageCanvas');
            //    canvas.width = encodedImage.width;
            //    canvas.height = encodedImage.height;
            //    var ctx = canvas.getContext('2d');
            //    ctx.drawImage(encodedImage,0,0);
            //    console.log(restore_array)
            //    //jpegUrl = canvas.toDataURL("image/jpeg");
            //}
            //encodedImage.src = initialImage

            context.putImageData(initialImage, 0, 0)

            const payLoad = {
                "method" : "clear",
                "clientId" : clientId_for_undo_or_clear,
                "sessionId" : sessionId_for_image_send,
            }

            ws.send(JSON.stringify(payLoad));
        } else {
            index -= 1
            restore_array.pop();
            console.log(restore_array)
            context.putImageData(restore_array[index], 0, 0)
            //var jpegUrl = canvas.toDataURL("image/jpeg");

            const payLoad = {
                "method" : "undo",
                "sessionId" : sessionId_for_image_send,
                "clientId" : clientId_for_undo_or_clear,
            }

            ws.send(JSON.stringify(payLoad));
        }
    }

</script>
</html>
